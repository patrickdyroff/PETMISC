There is a rising movement for security around websites known as “HTTPS Everywhere”. This is simply the rapid switching that websites are doing from the old application protocol (HTTP) to that of a more secure method (HTTPS). This changes the connection from an unencrypted and easy-to-exploit approach to one that is encrypted and more secure. It works by layering the Hypertext Transfer Protocol (HTTP) on top of the SSL/TLS protocol, thus adding the security capabilities of SSL/TLS to standard HTTP communications. The main motivation for HTTPS is to prevent wiretapping and man-in-the-middle attacks. This encryption process works as so. After building a TCP connection, the SSL handshake is started by the client. The client (which can be a browser as well as any other program such as Windows Update or PuTTY) sends a number of specifications: which version of SSL/TLS it is running, what ciphersuites it wants to use, and what compression methods it wants to use. The server checks what the highest SSL/TLS version is that is supported by them both, picks a ciphersuite from one of the client's options (if it supports one), and optionally picks a compression method. After this the basic setup is done, the server sends its certificate. This certificate must be trusted by either the client itself or a party that the client trusts. Having verified the certificate and being certain this server really is who he claims to be (and not a man in the middle), a key is exchanged. This can be a public key. Both the server and the client can now compute the key for the symmetric encryption. The client tells the server that from now on, all communication will be encrypted, and sends an encrypted and authenticated message to the server. The server verifies that the MAC address (used for authentication) is correct, and that the message can be correctly decrypted. It then returns a message, which the client verifies as well.The handshake is now finished, and the two hosts can communicate securely. To close the connection, a close_notify 'alert' is used. If an attacker tries to terminate the connection by finishing the TCP connection (injecting a FIN packet), both sides will know the connection was improperly terminated. The connection cannot be compromised by this though, merely interrupted. 

Most safe websites will use a certificate that they purchase from a Certificate authority. This makes the connection more trustworthy and the browser has no problem granting you access to the website. But many websites create their own certificates; these are known as self-signed certificates and are not always trusted. Therefore, most browsers will notify the user when they are connecting to a website with a self-signed certificate and will ask whether or not to trust the connection. This is where my plug-in is put in place.

My project is a Plug-in for an Experimental Trust Model Involving Self-signed Certificates (PETMISC). Many users would like to visit a website but don’t feel that it is safe to do so. My plug-in gives the user more choices when they visit a website with a self-signed certificate. There are usually two options that a browser would give: completely block any connections to a server, thus not allowing the user to access any of the webserver’s content and visa versa, or allow the user to connect the server and run the risk of malicious intent that a web server may have. This blacklist and whitelist method is not a perfect design. My plug-in includes a third option: the greylist. The greylist includes any website that a user might want to view but block any data traveling the other way. This creates an environment for the user that will allow them to access all the content that a website would offer without the danger of sending any private information such as credit card numbers, social security numbers or any sensitive data that he or she would not want to be sent. This read-but-not-write option will fit many users needs as they can feel more secure in surfing an unsafe internet. 
